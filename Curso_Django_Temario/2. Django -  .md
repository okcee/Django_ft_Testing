


# El Sitio de Administración (Admin Site)

El sitio de administración de Django es una interfaz autogenerada que permite a usuarios con permisos (como superusuarios) crear, ver, actualizar y eliminar datos de tus Modelos.

## 1. Acceso y Autenticación

* Se accede a través de la URL `/admin/` (configurada por defecto en el `urls.py` del proyecto).
* Requiere que el usuario esté autenticado.
* Para crear un usuario con acceso total, usa `python manage.py createsuperuser`.

## 2. Registro de Modelos (`admin.py`)

Para que un Modelo aparezca en el sitio de administración, debe ser registrado en el archivo `admin.py` de la aplicación donde reside el Modelo.

'from django.contrib import admin'
'from .models import NombreModelo'
'admin.site.register(NombreModelo)'

## 3. Personalización del Admin (`admin.ModelAdmin`)

Puedes personalizar la apariencia y el comportamiento de los formularios y listas de objetos en el admin creando una clase que herede de `admin.ModelAdmin` y pasándola como segundo argumento a `admin.site.register()`.

'from django.contrib import admin'
'from .models import NombreModelo'
'class NombreModeloAdmin(admin.ModelAdmin):'
'    readonly_fields = ('created', 'updated') # Define campos de solo lectura'
'    list_display = ('campo1', 'campo2', 'fecha') # Define columnas en la lista de objetos'
'    ordering = ('-fecha',) # Define el orden inicial de la lista'
'    search_fields = ('campo1', 'campo2') # Habilita búsqueda por estos campos'

'admin.site.register(NombreModelo, NombreModeloAdmin)'

## 4. Nombres de Apps y Modelos en el Admin (`verbose_name`)

* Para cambiar el nombre legible de una aplicación en el admin, define `verbose_name` en la clase `AppConfig` de la app (`apps.py`) y asegúrate de que `INSTALLED_APPS` en `settings.py` use la ruta completa a esta clase (`'nombre_app.apps.NombreAppConfig'`).
* Para cambiar el nombre legible de un Modelo (singular y plural) en el admin y otras partes de Django, define `verbose_name` y `verbose_name_plural` en la subclase `Meta` del Modelo.

# Manejo de Archivos Estáticos y Media

Django distingue entre archivos estáticos (parte del código fuente: CSS, JS, imágenes del diseño) y archivos media (subidos por los usuarios).

## 1. Archivos Estáticos

* **Configuración:** `STATIC_URL` es obligatorio en `settings.py`. Opcionalmente `STATICFILES_DIRS` para directorios a nivel de proyecto y `STATIC_ROOT` para `collectstatic`. `APP_DIRS: True` (por defecto en `TEMPLATES`) hace que Django busque en `static/` subdirectorios dentro de las apps instaladas.
* **Organización:** Convención `nombre_app/static/nombre_app/` para archivos de aplicación.
* **Uso en Plantillas:** `{% load static %}` y `{% static 'ruta/al/archivo' %}`.
* **Servir en Desarrollo:** Se maneja automáticamente por el servidor de desarrollo si `DEBUG=True` y la app `django.contrib.staticfiles` está en `INSTALLED_APPS`.

## 2. Archivos Media

* **Configuración:** `MEDIA_URL` (URL pública) y `MEDIA_ROOT` (ruta del sistema de archivos) son obligatorios en `settings.py`.
* **Almacenamiento:** Se especifica el subdirectorio dentro de `MEDIA_ROOT` usando el atributo `upload_to` en campos `FileField` o `ImageField` del Modelo.
* **Uso en Plantillas:** Se obtiene la URL utilizando el atributo `.url` del campo del Modelo: `{{ objeto.campo_archivo.url }}`.
* **Servir en Desarrollo:** Requiere añadir una configuración específica al `urlpatterns` del `urls.py` principal *solo si `DEBUG` es `True`*:
    'from django.conf import settings'
    'from django.conf.urls.static import static'
    '# ... urlpatterns ...'
    'if settings.DEBUG:'
    '    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)'

## 3. Diferencia Clave

Los archivos estáticos son fijos y se despliegan una vez; los archivos media son dinámicos, cambian a medida que los usuarios interactúan con la aplicación y requieren manejo especial para subida y acceso.

# Patrón MVT con Interacción con Base de Datos

Cuando se integran Modelos, el flujo MVT se expande:

1.  **Petición:** El navegador solicita una URL.
2.  **URL Dispatcher (`urls.py`):** Mapea la URL a una Vista.
3.  **Vista (`views.py`):**
    * Recibe el objeto `request`.
    * **Interactúa con el Modelo (ORM):** Utiliza el Manager (`.objects`) del Modelo para realizar consultas a la base de datos (ej: `Modelo.objects.all()` para obtener todos los objetos, que devuelve un QuerySet).
    * Prepara los datos obtenidos en un diccionario de `contexto`.
    * Renderiza un Template usando `render()`, pasando el objeto `request`, el nombre del Template y el diccionario de `contexto`.
4.  **Template (`.html`):**
    * Recibe el diccionario de `contexto`.
    * Utiliza el Django Template Language (DTL) para mostrar los datos dinámicos (`{{ variables }}`), iterar sobre colecciones (`{% for %}` QuerySets), y aplicar lógica condicional (`{% if %}`).
    * Puede heredar de una plantilla base (`{% extends %}`, `{% block %}`) y referenciar archivos estáticos (`{% load static %}`, `{% static %}`) o media (`{{ field.url }}`).
5.  **Respuesta:** La Vista devuelve un objeto `HttpResponse` con el HTML generado por el motor de plantillas, que el servidor envía al navegador.

La separación de la lógica de consulta a la base de datos (en la Vista) de la definición de los datos (en el Modelo) y la presentación (en el Template) es fundamental para la estructura MVT de Django.

---

Este resumen extendido cubre la creación y uso de Modelos, la gestión de la base de datos a través de migraciones, el aprovechamiento del sitio de administración para gestionar datos, el manejo de archivos estáticos y media, y cómo todos estos componentes se integran en el patrón MVT para construir aplicaciones web dinámicas con Django.